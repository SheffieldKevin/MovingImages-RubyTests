#!/usr/bin/env ruby
# Copyright (C) 2014 Kevin Meaney
# Script for testing smig and moving images.
# Please refer to the file LICENSE for the license agreement.
# You are granted the rights to modify this file for your own purposes
# or for distribution to third parties. In either case you accept all
# responsibility for liability.
# 
# test018
# This script file is for testing interacting with the MovieEditor class and
# objects of that class.
# Testing covers:
# 1. Getting a list of all export presets from the class.
# 1.1 Get the number of open movie editor objects.
# 2. Create a movie editor object.
# 2.1 Confirm that the number of movie editor objects is 1.
# 2.2 Add a video track to the movie editor.
# 2.3 Confirm that there is one video track.
# 2.4 Add a movie segment.
# 2.5 Add an empty segment.
# 2.6 Add a second movie segment.
# 2.7 Get the segment mappings.
# 
# 3. Adding a few different video writer inputs.
# 4. Getting properties from the video writer objects with different inputs.
# 5. For H264, ProRes4444 and ProRes422 codecs test creation of files.
# 6. Don't try and do comparison of actual movie pixels. Do test dimensions
#      and movie length.
# Test path substitution when creating a movie writer class.

require 'Open3'
require 'JSON'
require 'tmpdir'
require 'securerandom'

require 'moving_images'

include MovingImages
include MIMovie
include MICGDrawing
include CommandModule

$errorcode = 0

$filename = File.basename(__FILE__)
$directory = File.expand_path(File.dirname(__FILE__))
$compareImageDir = File.join($directory, "images/test018ForComparison")
$compareImages = File.join($directory, "compareimages")

def AreImageFilesSame(filePath1, filePath2, distance=0)
  # assume paths already expanded.
  # distance is a integer that will need to be a string. Default value
  # assumes that we want the difference to be zero.
  result, exitVal = Open3.capture2($compareImages, "-file1", filePath1,
                              "-file2", filePath2, "-distance", distance.to_s)
  unless exitVal.exitstatus.zero?
    raise "failed to compare files"
  end
  return result.eql? "SAME"
end

# Get a list of all the possible movie editor export presets.
# Get the number of open movie editor objects. Should be 0.
def test01()
  begin
    movieExportPresets = MIMeta.listmovieeditorexportpresets
    origResult = "AVAssetExportPresetAppleM4VWiFi AVAssetExportPresetAppleM4V480pSD "\
    "AVAssetExportPresetAppleM4V1080pHD AVAssetExportPresetAppleM4VCellular "\
    "AVAssetExportPreset1920x1080 AVAssetExportPreset1280x720 "\
    "AVAssetExportPreset640x480 AVAssetExportPresetAppleM4ViPod "\
    "AVAssetExportPreset3840x2160 AVAssetExportPresetAppleM4VAppleTV "\
    "AVAssetExportPresetAppleM4V720pHD AVAssetExportPreset960x540 "\
    "AVAssetExportPresetAppleM4A AVAssetExportPresetAppleProRes422LPCM"
    
    # Now lets check the list of presets obtained to one we prepared earlier.
    fail "List of movie editor export presets is different" unless origResult.eql?(
                                                            movieExportPresets)

    # Get the nuber of movie editor objects.
    numObjects = Smig.get_classtypeproperty(objecttype: :movieeditor,
                                              property: :numberofobjects)
    fail "Number of movie editor objects should be 0" unless numObjects.eql?("0")

  rescue RuntimeError => e
    $errorcode = Smig.exitvalue
    unless $errorcode.zero?
      puts "Exit string: " + Smig.exitstring
      puts " Exit status: " + $errorcode.to_s
    end
    puts e.message
    puts e.backtrace.to_s
  end
end

# 2.0 Create a movie editor object.
# 2.1 Confirm that the number of movie editor objects is 1.
# 2.2 Add a video track to the movie editor.
# 2.3 Confirm that there is one video track.
# 2.4 Add a movie segment.
# 2.5 Get the segment mappings.
# 2.6 Add an empty segment.
# 2.7 Add a second movie segment.
# 2.8 Get the segment mappings.
# 2.9 Add a single passthru instruction for the length of the movie.
# 2.10 Copy the composition map image to the image collection.
# 2.11 Save the composition map image
# 2.12 Compare the composition map image with a previously generated one.
# 2.13 Export the video compostion.
# 2.14 Import the exported movie and check movie length and size.

def test02()
  movieEditorObject = nil
  begin
    theCommands = SmigCommands.new
    cleanupCommands = SmigCommands.new
    # 2.0 Create a movie editor object.
    movieEditorObject = theCommands.make_createmovieeditor(addtocleanup: false)

    cleanupCommands.add_tocleanupcommands_closeobject(movieEditorObject)
    # 2.1 Confirm that the number of movie editor objects is 1.
    getNumMovieEditorObjects = CommandModule.make_get_nonobjectproperty(
                                          property: :numberofobjects,
                                              type: :movieeditor)
    theCommands.add_command(getNumMovieEditorObjects)

    numObjects = Smig.perform_commands(theCommands)
    fail "Number of movie editor objects should 1" unless numObjects.eql?("1")
    
    # 2.2 Add a video tracks.
    # Specify the track persistent id.
    theCommands = SmigCommands.new
    targetTrackID = 3
    addVideoTrack = CommandModule.make_createtrackcommand(movieEditorObject,
                                     mediatype: :vide,
                                       trackid: targetTrackID)
    theCommands.add_command(addVideoTrack)
    targetTID = MovieTrackIdentifier.make_movietrackid_from_persistenttrackid(
      targetTrackID)

=begin
    # Leave track id unspecified and one will be assigned.
    addVideoTrack2 = CommandModule.make_createtrackcommand(movieEditorObject,
                                     mediatype: :vide)
    theCommands.add_command(addVideoTrack2)
=end

    # 2.3 Confirm that there is one video tracks.
    getNumVideoTracks = CommandModule.make_get_objectproperty(movieEditorObject,
                                                      property: :numberoftracks)
    getNumVideoTracks.add_option(key: :mediatype, value: :vide)
    theCommands.add_command(getNumVideoTracks)
    
    numTracks = Smig.perform_commands(theCommands)
    fail "Number of video tracks should be 1 is #{numTracks}" unless numTracks.eql?("1")

    # 2.4 Add a movie segment
    theCommands = SmigCommands.new
    # First, we need to import a movie so that we have content to add.
    sourceMovie = File.join($directory, "images/testinput-movingimages.mov")
    movieImporter = theCommands.make_createmovieimporter(sourceMovie,
                                                         addtocleanup: false)
    cleanupCommands.add_tocleanupcommands_closeobject(movieImporter)
    # Then specify that the content is from the first video track of importer
    sourceTrack = MovieTrackIdentifier.make_movietrackid_from_mediatype(
      mediatype: :vide, trackindex: 0)
    
    # Set up the insertion time, and the source time range.
    timeZero = MovieTime.make_movietime(timevalue: 0, timescale: 6000)
    duration = MovieTime.make_movietime(timevalue: 12000, timescale: 6000)
    sourceTimeRange = MovieTime.make_movie_timerange(start: timeZero,
                                                  duration: duration)
    insertionTime = MovieTime.make_movietime(timevalue: 0, timescale: 6000)
    insertTrackSegmentCommand = CommandModule.make_inserttracksegment(
                                movieEditorObject, 
                         track: targetTID,
                 source_object: movieImporter,
                  source_track: sourceTrack,
                 insertiontime: insertionTime, 
              source_timerange: sourceTimeRange)

    theCommands.add_command(insertTrackSegmentCommand)
    
    # 2.5 Create the get segment mappings command.
    getSegmentMappingsCommand = CommandModule.make_get_objectproperty(
                                movieEditorObject,
                      property: :tracksegmentmappings)
    getSegmentMappingsCommand.add_option(key: :track, value: targetTID)
    theCommands.add_command(getSegmentMappingsCommand)
    result = Smig.perform_commands(theCommands)
    expectedResult = '[{"sourcetimerange":{"start":{"flags":1,"value":0,'\
    '"timescale":6000,"epoch":0},"duration":{"flags":1,"value":12000,"timescale"'\
    ':6000,"epoch":0}},"targettimerange":{"start":{"flags":1,"value":0,'\
    '"timescale":6000,"epoch":0},"duration":{"flags":1,"value":12000,'\
    '"timescale":6000,"epoch":0}}}]'
    
    unless expectedResult.eql?(result)
      fail "1. Segment mapping different from expected #{result}"
    end

    # 2.6 Add an empty segment. This should push original segment later by 2 secs
    theCommands = SmigCommands.new
    emptySegmentTimeRange = MovieTime.make_movie_timerange(start: timeZero,
                                                        duration: duration)
    insertEmptySegmentCommand = CommandModule.make_insertemptysegment(
                                    movieEditorObject,
                             track: targetTID,
                insertiontimerange: emptySegmentTimeRange)
    theCommands.add_command(insertEmptySegmentCommand)
    theCommands.add_command(getSegmentMappingsCommand)
    result = Smig.perform_commands(theCommands)
    expectedResult = '[{"sourcetimerange":{"start":{"flags":1,"value":0,'\
    '"timescale":6000,"epoch":0},"duration":{"flags":1,"value":12000,'\
    '"timescale":6000,"epoch":0}},"targettimerange":{"start":{"flags":1,'\
    '"value":12000,"timescale":6000,"epoch":0},"duration":{"flags":1,"value":'\
    '12000,"timescale":6000,"epoch":0}}}]'
    
    unless expectedResult.eql?(result)
      fail "2. Segment mapping different from expected #{result}"
    end

    # 2.7 Add a second movie segment.
    theCommands = SmigCommands.new
    timeTwoSecsIn = MovieTime.make_movietime(timevalue: 12000, timescale: 6000)
    duration = MovieTime.make_movietime(timevalue: 12000, timescale: 6000)
    sourceTimeRange = MovieTime.make_movie_timerange(start: timeTwoSecsIn,
                                                  duration: duration)
    insertionTime = timeZero
    insertTrackSegmentCommand = CommandModule.make_inserttracksegment(
                                movieEditorObject, 
                         track: targetTID,
                 source_object: movieImporter,
                  source_track: sourceTrack,
                 insertiontime: insertionTime, 
              source_timerange: sourceTimeRange)

    theCommands.add_command(insertTrackSegmentCommand)
    # 2.8 Add a get segments mapping command.
    theCommands.add_command(getSegmentMappingsCommand)
    result = Smig.perform_commands(theCommands)
    expectedResult = '[{"sourcetimerange":{"start":{"flags":1,"value":12000,'\
    '"timescale":6000,"epoch":0},"duration":{"flags":1,"value":12000,'\
    '"timescale":6000,"epoch":0}},"targettimerange":{"start":{"flags":1,'\
    '"value":0,"timescale":6000,"epoch":0},"duration":{"flags":1,"value":12000,'\
    '"timescale":6000,"epoch":0}}},{"sourcetimerange":{"start":{"flags":1,'\
    '"value":0,"timescale":6000,"epoch":0},"duration":{"flags":1,"value":12000'\
    ',"timescale":6000,"epoch":0}},"targettimerange":{"start":{"flags":1,'\
    '"value":24000,"timescale":6000,"epoch":0},"duration":{"flags":1,"value"'\
    ':12000,"timescale":6000,"epoch":0}}}]'
    unless expectedResult.eql?(result)
      fail "3. Segment mapping different from expected #{result}"
    end

    # 2.9 Add a single passthru layer instruction to cover length of video track.
    theCommands = SmigCommands.new
    sixSeconds = MovieTime.make_movietime(timevalue: 36000, timescale: 6000)

    instructionTimeRange = MovieTime.make_movie_timerange(start: timeZero,
                                                       duration: sixSeconds)
    layerInstructions = VideoLayerInstructions.new
    layerInstructions.add_passthrulayerinstruction(track: targetTID)
    videoInstruction = CommandModule.make_addvideoinstruction(movieEditorObject,
                            timerange: instructionTimeRange,
                    layerinstructions: layerInstructions)
    theCommands.add_command(videoInstruction)
    # 2.10 Copy the composition map image to the image collection.
    imageIdentifier = SecureRandom.uuid
    addCompositionToImageCollection = CommandModule.make_assignimage_tocollection(
                                                movieEditorObject,
                        image_creation_options: nil,
                                    identifier: imageIdentifier)
    theCommands.add_command(addCompositionToImageCollection)
    cleanupCommands.add_tocleanupcommands_removeimagefromcollection(imageIdentifier)
    # 2.11 Save the composition map image
    # First create an image exporter object and add it to the cleanup commands.
    compMapFileName = "compositionmap.jpg"
    exportPath = File.join(Dir.tmpdir(), compMapFileName)
    exporterObject = theCommands.make_createexporter(exportPath,
                                        export_type: "public.jpeg",
                                       addtocleanup: false)
    cleanupCommands.add_tocleanupcommands_closeobject(exporterObject)
    addImageToExporterCommand = CommandModule.make_addimage_fromimagecollection(
      exporterObject, imageidentifier: imageIdentifier)
    theCommands.add_command(addImageToExporterCommand)
    exportCommand = CommandModule.make_export(exporterObject)
    theCommands.add_command(exportCommand)
    Smig.perform_commands(theCommands)
    # `open #{exportPath}`
    origFile = File.join($compareImageDir, compMapFileName)
    compareResult = AreImageFilesSame(origFile, exportPath, 0)
    unless compareResult
      # 2.12 Report if different.
      fail "2.12 Different image files: " + origFile + " and " + tempFile
    end

    # 2.13 Export the movie composition.
    theCommands.clear
    movieFileName = "videowithemptysegment.mov"
    movieExportPath = File.join(Dir.tmpdir(), movieFileName)
    fileType = "com.apple.quicktime-movie"
    exportMovieCommand = CommandModule.make_movieeditor_export(movieEditorObject,
                                exportpreset: :AVAssetExportPreset1280x720,
                              exportfilepath: movieExportPath,
                              exportfiletype: fileType)
    theCommands.add_command(exportMovieCommand)
    Smig.perform_commands(theCommands)
    # `open #{movieExportPath}`
    theCommands.clear
    movieImporter2 = theCommands.make_createmovieimporter(movieExportPath,
                                           addtocleanup: false)
    cleanupCommands.add_tocleanupcommands_closeobject(movieImporter2)
    getMovieTrackPropertiesCommand = CommandModule.make_get_objectproperties(
                                                          movieImporter2)
    theTrack = MovieTrackIdentifier.make_movietrackid_from_mediatype(
      mediatype: :vide, trackindex: 0)

    getMovieTrackPropertiesCommand.add_option(key: :track, value: theTrack)
    theCommands.add_command(getMovieTrackPropertiesCommand)
    theResult = Smig.perform_commands(theCommands)
    origResult = JSON.parse('{"naturalsize":{"width":1280,"height":720},'\
    '"minframeduration":{"flags":1,"value":3002,"timescale":90000,"epoch":0},'\
    '"mediatype":"vide","timerange":{"start":{"flags":1,"value":0,"timescale":'\
    '90000,"epoch":0},"duration":{"flags":1,"value":540360,"timescale":90000'\
    ',"epoch":0}},"trackid":1,"languagecode":"und","languagetag":"",'\
    '"affinetransform":{"m12":0,"m21":0,"m22":1,"tY":0,"m11":1,"tX":'\
    '0},"requiresframereordering":true,"trackenabled":true,"framerate":29.98001}')
    newResult = JSON.parse(theResult)
    # puts "#{origResult}"
    # puts "#{newResult}"
    unless origResult["naturalsize"]["width"].eql?(newResult["naturalsize"]["width"]) &&
          origResult["timerange"]["duration"]["value"].eql?(newResult["timerange"]["duration"]["value"])
      fail "2.14 Different track properties: #{theResult}"
    end
    # puts theResult
    
  rescue RuntimeError => e
    $errorcode = Smig.exitvalue
    unless $errorcode.zero?
      puts "Exit string: " + Smig.exitstring
      puts " Exit status: " + $errorcode.to_s
    end
    puts e.message
    puts e.backtrace.to_s
  ensure
    Smig.perform_commands(cleanupCommands)
    FileUtils.rm_f(exportPath) unless exportPath.nil?
    FileUtils.rm_f(movieExportPath) unless movieExportPath.nil?
  end
end

# Tests creating and automically close video writer objects.
# Video writer created that will export as mp4, mov and m4v.
# Tests getting properties of 
def xtest01()
  destMovieFileNameMP4 = "movie01.mp4"
  destMovieFileNameMOV = "movie02.mov"
  destMovieFileNameM4V = "movie03.m4v"
  begin
    # Test with a mpeg4 file type.
    
    # Create the list of commands object.
    theCommands = SmigCommands.new
    theCommands.saveresultstype = :lastcommandresult
     
    movieFilePath = File.join(Dir.tmpdir(), destMovieFileNameMP4)
    videoWriterName = "videowriter.test01.name"
    utiFileType = "public.mpeg-4"
    movieWriter = theCommands.make_createvideoframeswriter(movieFilePath,
                                          addtocleanup: true,
                                                  name: videoWriterName,
                                           utifiletype: utiFileType,
                                   pathsubstitutionkey: nil)
     
    getMovieWriterProps = CommandModule.make_get_objectproperties(movieWriter,
                                            saveresultstype: :jsonstring)
    theCommands.add_command(getMovieWriterProps)
    result = Smig.perform_commands(theCommands)
    oldResH = { 
                            "file" => "/This/Path/Is/Ignored",
                      "objectname" => videoWriterName,
                      "objecttype" => "videoframeswriter",
                     "utifiletype" => utiFileType,
                  "canwriteframes" => false,
               "videowriterstatus" => 0
              }
    newResH = JSON.parse(result)
    
    # Compare the different property hashes.
    compare_videowriterproperties_hash(oldResH, newResH)

    # Now lets ask for the number of objects. Should be 0.
    fail "Video writer object not closed" unless Smig.get_numberofobjects().eql? 0
    
    # Test with a quicktime file type.

    # Create the list of commands object.
    theCommands = SmigCommands.new
    theCommands.saveresultstype = :lastcommandresult
     
    movieFilePath = File.join(Dir.tmpdir(), destMovieFileNameMOV)
    videoWriterName = "videowriter.test01.name"
    utiFileType = "com.apple.quicktime-movie"
    movieWriter = theCommands.make_createvideoframeswriter(movieFilePath,
                                          addtocleanup: true,
                                                  name: videoWriterName,
                                           utifiletype: utiFileType,
                                   pathsubstitutionkey: nil)
     
    getMovieWriterProps = CommandModule.make_get_objectproperties(movieWriter,
                                            saveresultstype: :jsonstring)
    theCommands.add_command(getMovieWriterProps)
    result = Smig.perform_commands(theCommands)
    oldResH = { 
                            "file" => "/This/Path/Is/Ignored",
                      "objectname" => videoWriterName,
                      "objecttype" => "videoframeswriter",
                     "utifiletype" => utiFileType,
                  "canwriteframes" => false,
               "videowriterstatus" => 0
              }
    newResH = JSON.parse(result)
    
    # Compare the different property hashes.
    compare_videowriterproperties_hash(oldResH, newResH)
    
    # Now lets ask for the number of objects. Should be 0.
    fail "Video writer object not closed" unless Smig.get_numberofobjects().eql? 0

    # Test with a m4v file type.

    # Create the list of commands object.
    theCommands = SmigCommands.new
    theCommands.saveresultstype = :lastcommandresult
     
    movieFilePath = File.join(Dir.tmpdir(), destMovieFileNameM4V)
    videoWriterName = "videowriter.test01.name"
    utiFileType = "com.apple.m4v-video"
    movieWriter = theCommands.make_createvideoframeswriter(movieFilePath,
                                          addtocleanup: true,
                                                  name: videoWriterName,
                                           utifiletype: utiFileType,
                                   pathsubstitutionkey: nil)
     
    getMovieWriterProps = CommandModule.make_get_objectproperties(movieWriter,
                                            saveresultstype: :jsonstring)
    theCommands.add_command(getMovieWriterProps)
    result = Smig.perform_commands(theCommands)
    oldResH = { 
                  "file" => "/This/Path/Is/Ignored",
                      "objectname" => videoWriterName,
                      "objecttype" => "videoframeswriter",
                     "utifiletype" => utiFileType,
                  "canwriteframes" => false,
               "videowriterstatus" => 0
              }
    newResH = JSON.parse(result)
    
    # Compare the different property hashes.
    compare_videowriterproperties_hash(oldResH, newResH)
    
    # Now lets ask for the number of objects. Should be 0.
    fail "Video writer object not closed" unless Smig.get_numberofobjects().eql? 0

    # One last test. Check that we can get a single property.
    # In this case the utifiletype.
    # Create the list of commands object.
    theCommands = SmigCommands.new
    theCommands.saveresultstype = :lastcommandresult
     
    movieFilePath = File.join(Dir.tmpdir(), destMovieFileNameM4V)
    videoWriterName = "videowriter.test01.name"
    utiFileType = "com.apple.m4v-video"
    movieWriter = theCommands.make_createvideoframeswriter(movieFilePath,
                                          addtocleanup: true,
                                                  name: videoWriterName,
                                           utifiletype: utiFileType,
                                   pathsubstitutionkey: nil)
     
    getMovieWriterProp = CommandModule.make_get_objectproperty(movieWriter,
                                            property: :utifiletype)
    theCommands.add_command(getMovieWriterProp)
    result = Smig.perform_commands(theCommands)

    fail "utifiletype different to assigned: " unless result.eql? utiFileType

    # Now lets ask for the number of objects. Should be 0.
    fail "Video writer object not closed" unless Smig.get_numberofobjects().eql? 0

  rescue RuntimeError => e
    $errorcode = Smig.exitvalue
    unless $errorcode.zero?
      puts "Exit string: " + Smig.exitstring
      puts " Exit status: " + $errorcode.to_s
    end
    puts e.message
    puts e.backtrace.to_s
  end
end

# Test adding an input to a video writer object.
# Set the file type to quicktime.
# All the presets for the inputs will be tested.
# Once again we will request all the associated properties.

def xtest02()
  movieFileName = "movie01.mov"
  begin
    theCommands = SmigCommands.new
    theCommands.saveresultstype = :lastcommandresult
     
    movieFilePath = File.join("/blah", movieFileName)
    videoWriterName = "videowriter.test02.name"
    utiFileType = "com.apple.quicktime-movie"
    movieWriter = theCommands.make_createvideoframeswriter(movieFilePath,
                                          addtocleanup: true,
                                                  name: videoWriterName,
                                           utifiletype: utiFileType,
                                   pathsubstitutionkey: nil)
    
    # Now add the h264_sd input to the video writer object
    frameduration = MIMovie::MovieTime.make_movietime(timevalue: 1001,
      timescale: 30000)
    cleanAperture = MIMovie::CleanAperture.make_cleanaperture(0, 30, 640, 420)
    addVideoInputCommand = CommandModule.make_addinputto_videowritercommand(
      movieWriter, preset: :h264preset_sd, framesize: { width: 640, height: 480 },
      frameduration: frameduration, cleanaperture: cleanAperture,
      scalingmode: :AVVideoScalingModeResizeAspect)
    theCommands.add_command(addVideoInputCommand)
    
    getMovieWriterProps = CommandModule.make_get_objectproperties(movieWriter,
                                            saveresultstype: :jsonstring)
    theCommands.add_command(getMovieWriterProps)
    result = Smig.perform_commands(theCommands)
    oldRes = '{"objectname":"videowriter.test02.name","objecttype":'\
    '"videoframeswriter","videosettings":{"AVVideoCleanApertureKey":'\
    '{"AVVideoCleanApertureHorizontalOffsetKey":0,'\
    '"AVVideoCleanApertureHeightKey":420,"AVVideoCleanApertureVerticalOffsetKey"'\
    ':30,"AVVideoCleanApertureWidthKey":640},"AVVideoHeightKey":'\
    '480,"AVVideoCodecKey":"avc1","AVVideoCompressionPropertiesKey":{'\
    '"AverageBitRate":3145728,"MaxKeyFrameInterval":30,"ProfileLevel":'\
    '"H264_Baseline_AutoLevel","ExpectedFrameRate":30},"AVVideoWidthKey":'\
    '640,"AVVideoScalingModeKey":"AVVideoScalingModeResizeAspect"},'\
    '"frameduration":{"flags":1,"value":1001,"timescale":30000,"epoch":'\
    '0},"canwriteframes":true,"file":"\/blah\/movie01.mov","time":'\
    '{"flags":1,"value":0,"timescale":6000,"epoch":0},"size":{"width":640,'\
    '"height":480},"videowriterstatus":0,'\
    '"utifiletype":"com.apple.quicktime-movie"}'
    fail "Writer with input h264_sd properties different: " unless result.eql? oldRes

    # Now redo for h264_hd
    theCommands = SmigCommands.new
    theCommands.saveresultstype = :lastcommandresult
     
    movieWriter = theCommands.make_createvideoframeswriter(movieFilePath,
                                          addtocleanup: true,
                                                  name: videoWriterName,
                                           utifiletype: utiFileType,
                                   pathsubstitutionkey: nil)
    
    # Now add the h264_hd input to the video writer object
    frameduration = MIMovie::MovieTime.make_movietime(timevalue: 1001,
      timescale: 30000)
    cleanAperture = MIMovie::CleanAperture.make_cleanaperture(150, 0, 1620, 1080)
    addVideoInputCommand = CommandModule.make_addinputto_videowritercommand(
      movieWriter, preset: :h264preset_hd, framesize: { width: 1920, height: 1080 },
      frameduration: frameduration, cleanaperture: cleanAperture,
      scalingmode: :AVVideoScalingModeResizeAspect)
    theCommands.add_command(addVideoInputCommand)
    
    getMovieWriterProps = CommandModule.make_get_objectproperties(movieWriter,
                                            saveresultstype: :jsonstring)
    theCommands.add_command(getMovieWriterProps)
    result = Smig.perform_commands(theCommands)

    oldRes = '{"objectname":"videowriter.test02.name","objecttype":'\
    '"videoframeswriter","videosettings":{"AVVideoCleanApertureKey":'\
    '{"AVVideoCleanApertureHorizontalOffsetKey":150,'\
    '"AVVideoCleanApertureHeightKey":1080,"AVVideoCleanApertureVerticalOffsetKey"'\
    ':0,"AVVideoCleanApertureWidthKey":1620},"AVVideoHeightKey":1080,'\
    '"AVVideoCodecKey":"avc1","AVVideoCompressionPropertiesKey":'\
    '{"ProfileLevel":"H264_High_AutoLevel","AverageBitRate":15585760'\
    ',"H264EntropyMode":"CABAC","MaxKeyFrameInterval":30,"AllowFrameReordering":'\
    '1,"ExpectedFrameRate":30},"AVVideoWidthKey":1920,"AVVideoScalingModeKey":'\
    '"AVVideoScalingModeResizeAspect"},"frameduration":{"flags":1,"value":1001'\
    ',"timescale":30000,"epoch":0},"canwriteframes":true,"file":'\
    '"\/blah\/movie01.mov","time":{"flags":1,'\
    '"value":0,"timescale":6000,"epoch":0},"size":{"width":1920,"height":1080},'\
    '"videowriterstatus":0,"utifiletype"'\
    ':"com.apple.quicktime-movie"}'
    
    fail "Writer with input h264_hd properties different: " unless result.eql? oldRes

    # Now redo for jpegpreset
    theCommands = SmigCommands.new
    theCommands.saveresultstype = :lastcommandresult
     
    movieWriter = theCommands.make_createvideoframeswriter(movieFilePath,
                                          addtocleanup: true,
                                                  name: videoWriterName,
                                           utifiletype: utiFileType,
                                   pathsubstitutionkey: nil)
    
    # Now add the jpegpreset input to the video writer object
    frameduration = MIMovie::MovieTime.make_movietime(timevalue: 1001,
      timescale: 30000)
    addVideoInputCommand = CommandModule.make_addinputto_videowritercommand(
      movieWriter, preset: :jpegpreset, framesize: { width: 1280, height: 720 },
      frameduration: frameduration)
    theCommands.add_command(addVideoInputCommand)
    
    getMovieWriterProps = CommandModule.make_get_objectproperties(movieWriter,
                                            saveresultstype: :jsonstring)
    theCommands.add_command(getMovieWriterProps)
    result = Smig.perform_commands(theCommands)

    oldRes = '{"objectname":"videowriter.test02.name","objecttype":'\
    '"videoframeswriter","videosettings":{"AVVideoHeightKey":720,"AVVideoCodecKey"'\
    ':"jpeg","AVVideoWidthKey":1280,"AVVideoCompressionPropertiesKey":{"Quality":'\
    '0.85}},"frameduration":{"flags":1,"value":1001,"timescale":30000,"epoch":'\
    '0},"canwriteframes":true,"file":"\/blah\/movie01.mov","time":{"flags":1,'\
    '"value":0,"timescale":6000,"epoch":0},"size":{"width":1280,"height":720},'\
    '"videowriterstatus":0,"utifiletype":"com.apple.quicktime-movie"}'
    
    fail "Writer with input jpegpreset properties different: " unless result.eql? oldRes

    # Now redo for ProRes422
    theCommands = SmigCommands.new
    theCommands.saveresultstype = :lastcommandresult
     
    movieWriter = theCommands.make_createvideoframeswriter(movieFilePath,
                                          addtocleanup: true,
                                                  name: videoWriterName,
                                           utifiletype: utiFileType,
                                   pathsubstitutionkey: nil)
    
    # Now add the ProRes422 input to the video writer object
    frameduration = MIMovie::MovieTime.make_movietime(timevalue: 1001,
      timescale: 30000)
    addVideoInputCommand = CommandModule.make_addinputto_videowritercommand(
      movieWriter, preset: :prores422preset,
      framesize: { width: 1280, height: 720 }, frameduration: frameduration)
    theCommands.add_command(addVideoInputCommand)
    
    getMovieWriterProps = CommandModule.make_get_objectproperties(movieWriter,
                                            saveresultstype: :jsonstring)
    theCommands.add_command(getMovieWriterProps)
    result = Smig.perform_commands(theCommands)

    oldRes = '{"objectname":"videowriter.test02.name","objecttype":'\
    '"videoframeswriter","videosettings":{"AVVideoColorPropertiesKey":'\
    '{"TransferFunction":"ITU_R_709_2","YCbCrMatrix":"ITU_R_709_2",'\
    '"ColorPrimaries":"ITU_R_709_2"},"AVVideoCodecKey":"apcn",'\
    '"AVVideoHeightKey":720,"AVVideoWidthKey":1280,"AVVideoScalingModeKey":'\
    '"AVVideoScalingModeResizeAspect"},"frameduration":{"flags":1,"value":1001,'\
    '"timescale":30000,"epoch":0},"canwriteframes":true,"file":'\
    '"\/blah\/movie01.mov","time":{"flags":1,'\
    '"value":0,"timescale":6000,"epoch":0},"size":{"width":1280,"height":720}'\
    ',"videowriterstatus":'\
    '0,"utifiletype":"com.apple.quicktime-movie"}'
    
    fail "Writer with input ProRes422 properties different: " unless result.eql? oldRes

    # Now redo for ProRes4444
    theCommands = SmigCommands.new
    theCommands.saveresultstype = :lastcommandresult
     
    movieWriter = theCommands.make_createvideoframeswriter(movieFilePath,
                                          addtocleanup: true,
                                                  name: videoWriterName,
                                           utifiletype: utiFileType,
                                   pathsubstitutionkey: nil)
    
    # Now add the ProRes4444 input to the video writer object
    frameduration = MIMovie::MovieTime.make_movietime(timevalue: 1001,
      timescale: 30000)
    addVideoInputCommand = CommandModule.make_addinputto_videowritercommand(
      movieWriter, preset: :prores4444preset,
      framesize: { width: 1920, height: 1080 }, frameduration: frameduration)
    theCommands.add_command(addVideoInputCommand)
    
    getMovieWriterProps = CommandModule.make_get_objectproperties(movieWriter,
                                            saveresultstype: :jsonstring)
    theCommands.add_command(getMovieWriterProps)
    result = Smig.perform_commands(theCommands)
    # puts result
    oldRes = '{"objectname":"videowriter.test02.name","objecttype":'\
    '"videoframeswriter","videosettings":{"AVVideoColorPropertiesKey":'\
    '{"TransferFunction":"ITU_R_709_2","YCbCrMatrix":"ITU_R_709_2",'\
    '"ColorPrimaries":"ITU_R_709_2"},"AVVideoCodecKey":"ap4h","AVVideoHeightKey":'\
    '1080,"AVVideoWidthKey":1920,"AVVideoScalingModeKey":'\
    '"AVVideoScalingModeResizeAspect"},"frameduration":{"flags":1,"value":'\
    '1001,"timescale":30000,"epoch":0},"canwriteframes":true,"file":'\
    '"\/blah\/movie01.mov","time":{"flags"'\
    ':1,"value":0,"timescale":6000,"epoch":0},"size":{"width":1920,"height":'\
    '1080},"videowriterstatus":0,"utifiletype":"com.apple.quicktime-movie"}'
    
    fail "Writer with input ProRes4444 properties different: " unless result.eql? oldRes

  rescue RuntimeError => e
    $errorcode = Smig.exitvalue
    unless $errorcode.zero?
      puts "Exit string: " + Smig.exitstring
      puts " Exit status: " + $errorcode.to_s
    end
    puts e.message
    puts e.backtrace.to_s
  end
end

# test reading frames from an imported movie draw them and then write a movie.
def test03()
  movieFileName = "movie03.mov"
  # In this example source file and output dimensions are both 1280x720
  sourceMovie = File.join($directory, "images/testinput-movingimages.mov")
  utiFileType = "com.apple.quicktime-movie"

  begin
    # Create the list of commands object, ready to have commands added to it.
    theCommands = CommandModule::SmigCommands.new
    theCommands.saveresultstype = :lastcommandresult

    # Importer the movie file
    movieImporterName = SecureRandom.uuid
    movieImporter = theCommands.make_createmovieimporter(sourceMovie,
                                                 name: movieImporterName)

    contextSize = MIShapes.make_size(1280, 720)
    bitmapObject = theCommands.make_createbitmapcontext(size: contextSize,
                                        profile: :kCGColorSpaceGenericRGB)

    movieFilePath = File.join(File.expand_path("~/Desktop"), movieFileName)
    # Create the video frames writer object
    movieWriter = theCommands.make_createvideoframeswriter(movieFilePath,
                                      addtocleanup: true,
                                       utifiletype: utiFileType,
                               pathsubstitutionkey: nil)

    # Now add the ProRes422 input to the video writer object
    frameduration = MIMovie::MovieTime.make_movietime(timevalue: 400,
                                                      timescale: 6000)
    addVideoInputCommand = CommandModule.make_addinputto_videowritercommand(
        movieWriter, preset: :prores422preset, framesize: contextSize,
        frameduration: frameduration)
    theCommands.add_command(addVideoInputCommand)

    # Prepare to loop over accessing frames and add frames to video frame writer
    # Will do nothing else other than halve the speed by doubling frame duration
    # time.
    # lets get 60 frames.
    numberOfFrames = 60
    imageID = SecureRandom.uuid
    trackID = MIMovie::MovieTrackIdentifier.make_movietrackid_from_mediatype(
        mediatype: :vide, trackindex: 0)
    currentTime = MIMovie::MovieTime.make_movietime(timevalue: 120, timescale: 30)
    
    # I've needed to use drawing to a bitmap context because my old laptop is
    # incapable of creating the necessary color correction data to go from
    # the profile of the image frame from the movie importer to the pixel buffer.
    # Drawing to bitmap slows down the processing of the movie frames. When
    # writing a script for computers with better hardware and optimizing for
    # speed you could leave out the draw image code and swap it for the commented
    # out code.
    
    numberOfFrames.times do |frameIndex|
      currentTime = MIMovie::MovieTime.make_movietime(timevalue: 60 + frameIndex,
                                                      timescale: 30)
      # frameOptions = MIMovie::FrameOptions.new
      # frameOptions.frametime = currentTime
      # frameOptions.tracks = [trackID]
      #==================================================================
      drawImageElement = MIDrawImageElement.new
      drawImageElement.set_moviefile_imagesource(source_object: movieImporter,
          frametime: currentTime, tracks: [trackID])
      drawImageElement.destinationrectangle = MIShapes.make_rectangle(
          size: contextSize)
      drawImageCommand = CommandModule.make_drawelement(bitmapObject, 
          drawinstructions: drawImageElement, createimage: true)
      theCommands.add_command(drawImageCommand)
      addImageToWriterInput = CommandModule.make_addimageto_videoinputwriter(
          movieWriter, sourceobject: bitmapObject)
      #==================================================================
      # addImageToWriterInput = CommandModule.make_addimageto_videoinputwriter(
      # movieWriter, imageoptions: frameOptions, sourceobject: movieImporter)
      theCommands.add_command(addImageToWriterInput)
    end
    
    finalize = CommandModule.make_finishwritingframescommand(movieWriter)
    theCommands.add_command(finalize)
    result = Smig.perform_commands(theCommands)
    # The above will throw if an error occured.
  rescue RuntimeError => e
    $errorcode = Smig.exitvalue
    unless $errorcode.zero?
      puts "Exit string: " + Smig.exitstring
      puts " Exit status: " + $errorcode.to_s
    end
    puts e.message
    puts e.backtrace.to_s
  ensure
    FileUtils.rm_f(movieFilePath) unless movieFilePath.nil?
#    `open #{movieFilePath}`
  end
end

def LocalTestMain018()
  begin
    puts "test01"
    test01()
    puts "test02"
    test02()
#    puts "test03"
#    test03()
  rescue RuntimeError => e
    puts e.message
    # puts e.backtrace
    puts "Error code: #{$errorcode}"
    puts "Smig.exitstring: #{Smig.exitstring}"
    # don't allow the exception to propagate outside of this file.
  end
  return $errorcode
end

exit(LocalTestMain018())

