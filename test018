#!/usr/bin/env ruby
# Copyright (C) 2015 Zukini Ltd.
# Script for testing smig and moving images.
# Please refer to the file LICENSE for the license agreement.
# You are granted the rights to modify this file for your own purposes
# or for distribution to third parties. In either case you accept all
# responsibility for liability.
# 
# test018
# This script file is for testing interacting with the MovieEditor class and
# objects of that class.
# Testing covers:
#
# 1. Getting a list of all export presets from the class.
# 1.1 Get the number of open movie editor objects.
#
# 2. Create a movie editor object, add a single track and some content.
# 2.0 Create the movie editor object
# 2.1 Confirm that the number of movie editor objects is 1.
# 2.2 Add a video track to the movie editor.
# 2.3 Confirm that there is one video track.
# 2.4 Add a movie segment.
# 2.5 Get the segment mappings.
# 2.6 Add an empty segment.
# 2.7 Add a second movie segment.
# 2.8 Get the segment mappings.
# 2.9 Add a single passthru instruction for the length of the movie.
# 2.10 Copy the composition map image to the image collection.
# 2.11 Save the composition map image
# 2.12 Compare the composition map image with a previously generated one.
# 2.13 Export the video compostion.
# 2.14 Import the exported movie and check movie length and size.
# 
# 3 Create a movie editor object with multiple video tracks, with transitions.
# 3.0 Create a movie editor object
# 3.1 Add three video tracks.
# 3.2 Confirm that the number of tracks is 3.
# 3.3 Import a movie file.
# 3.4 Add content to all three tracks that overlaps.
# 3.5 Add instructions.
# 3.6 Copy the composition map image to the image collection.
# 3.7 Save the composition map image
# 3.8 Compare the composition map image with a previously generated one.
# 3.9 Export the video compostion.
# 3.10 Import the exported movie and check movie length and size.
#
# 4 Tests the application of audio instructions set volume, and volume ramp.
# 1. Import a movie file
# 2. Create a movie editor object.
# 3. Add a video track to the movie editor.
# 4. Add a 4 second segment to the video track from the imported movie.
# 5. Add a passthru layer instruction to the video track.
# 6. Add two audio tracks to the movie editor.
# 7. Add content (track segments to each of the two audio tracks.)
# 8. Set the volume for audio track 2 to 0 from the start.
# 9. Set the volume ramp for audio track 1 to go from 1 to 0. Time range 1..3
# 10. Set the volume ramp for audio track 2 to go from 0 to 1. Time range 1..3
# 11. Export the movie composition.
# 12. Assign the composition map image to the image collection
# 13. Add removing the composition map image command to cleanup commands.
# 14. Create an exporter.
# 15. Add image from image collection to exporter.
# 16. Export image
# 17. Compare images.
# 18. Compare movie file audio track metadata.


require 'Open3'
require 'JSON'
require 'tmpdir'
require 'securerandom'

require 'moving_images'

include MovingImages
include MIMovie
include MICGDrawing
include CommandModule

$errorcode = 0

$filename = File.basename(__FILE__)
$directory = File.expand_path(File.dirname(__FILE__))
$compareImageDir = File.join($directory, "images/test018ForComparison")
$compareImages = File.join($directory, "compareimages")

def AreImageFilesSame(filePath1, filePath2, distance=0)
  # assume paths already expanded.
  # distance is a integer that will need to be a string. Default value
  # assumes that we want the difference to be zero.
  result, exitVal = Open3.capture2($compareImages, "-file1", filePath1,
                              "-file2", filePath2, "-distance", distance.to_s)
  unless exitVal.exitstatus.zero?
    raise "failed to compare files"
  end
  return result.eql? "SAME"
end

# Get a list of all the possible movie editor export presets.
# Get the number of open movie editor objects. Should be 0.
def test01()
  begin
    movieExportPresets = MIMeta.listmovieeditorexportpresets
    origResult = "AVAssetExportPresetAppleM4VWiFi AVAssetExportPresetAppleM4V480pSD "\
    "AVAssetExportPresetAppleM4V1080pHD AVAssetExportPresetAppleM4VCellular "\
    "AVAssetExportPreset1920x1080 AVAssetExportPreset1280x720 "\
    "AVAssetExportPreset640x480 AVAssetExportPresetAppleM4ViPod "\
    "AVAssetExportPreset3840x2160 AVAssetExportPresetAppleM4VAppleTV "\
    "AVAssetExportPresetAppleM4V720pHD AVAssetExportPreset960x540 "\
    "AVAssetExportPresetAppleM4A AVAssetExportPresetAppleProRes422LPCM"
    
    # Now lets check the list of presets obtained to one we prepared earlier.
    fail "List of movie editor export presets is different" unless origResult.eql?(
                                                            movieExportPresets)

    # Get the nuber of movie editor objects.
    numObjects = Smig.get_classtypeproperty(objecttype: :movieeditor,
                                              property: :numberofobjects)
    fail "Number of movie editor objects should be 0" unless numObjects.eql?("0")

  rescue RuntimeError => e
    $errorcode = Smig.exitvalue
    unless $errorcode.zero?
      puts "Exit string: " + Smig.exitstring
      puts " Exit status: " + $errorcode.to_s
    end
    puts e.message
    puts e.backtrace.to_s
  end
end

# 2. Create a movie editor object, add a single track and some content.
# 2.0 Create the movie editor object
# 2.1 Confirm that the number of movie editor objects is 1.
# 2.2 Add a video track to the movie editor.
# 2.3 Confirm that there is one video track.
# 2.4 Add a movie segment.
# 2.5 Get the segment mappings.
# 2.6 Add an empty segment.
# 2.7 Add a second movie segment.
# 2.8 Get the segment mappings.
# 2.9 Add a single passthru instruction for the length of the movie.
# 2.10 Copy the composition map image to the image collection.
# 2.11 Save the composition map image
# 2.12 Compare the composition map image with a previously generated one.
# 2.13 Export the video compostion.
# 2.14 Import the exported movie and check movie length and size.

def test02()
  movieEditorObject = nil
  begin
    theCommands = SmigCommands.new
    cleanupCommands = SmigCommands.new
    # 2.0 Create a movie editor object.
    movieEditorObject = theCommands.make_createmovieeditor(addtocleanup: false)

    cleanupCommands.add_tocleanupcommands_closeobject(movieEditorObject)
    # 2.1 Confirm that the number of movie editor objects is 1.
    getNumMovieEditorObjects = CommandModule.make_get_nonobjectproperty(
                                          property: :numberofobjects,
                                              type: :movieeditor)
    theCommands.add_command(getNumMovieEditorObjects)

    numObjects = Smig.perform_commands(theCommands)
    fail "Number of movie editor objects should 1" unless numObjects.eql?("1")
    
    # 2.2 Add a video tracks.
    # Specify the track persistent id.
    theCommands = SmigCommands.new
    targetTrackID = 3
    addVideoTrack = CommandModule.make_createtrackcommand(movieEditorObject,
                                     mediatype: :vide,
                                       trackid: targetTrackID)
    theCommands.add_command(addVideoTrack)
    targetTID = MovieTrackIdentifier.make_movietrackid_from_persistenttrackid(
      targetTrackID)

=begin
    # Leave track id unspecified and one will be assigned.
    addVideoTrack2 = CommandModule.make_createtrackcommand(movieEditorObject,
                                     mediatype: :vide)
    theCommands.add_command(addVideoTrack2)
=end

    # 2.3 Confirm that there is one video tracks.
    getNumVideoTracks = CommandModule.make_get_objectproperty(movieEditorObject,
                                                      property: :numberoftracks)
    getNumVideoTracks.add_option(key: :mediatype, value: :vide)
    theCommands.add_command(getNumVideoTracks)
    
    numTracks = Smig.perform_commands(theCommands)
    fail "Number of video tracks should be 1 is #{numTracks}" unless numTracks.eql?("1")

    # 2.4 Add a movie segment
    theCommands = SmigCommands.new
    # First, we need to import a movie so that we have content to add.
    sourceMovie = File.join($directory, "images/testinput-movingimages.mov")
    movieImporter = theCommands.make_createmovieimporter(sourceMovie,
                                                         addtocleanup: false)
    cleanupCommands.add_tocleanupcommands_closeobject(movieImporter)
    # Then specify that the content is from the first video track of importer
    sourceTrack = MovieTrackIdentifier.make_movietrackid_from_mediatype(
      mediatype: :vide, trackindex: 0)
    
    # Set up the insertion time, and the source time range.
    timeZero = MovieTime.make_movietime(timevalue: 0, timescale: 6000)
    duration = MovieTime.make_movietime(timevalue: 12000, timescale: 6000)
    sourceTimeRange = MovieTime.make_movie_timerange(start: timeZero,
                                                  duration: duration)
    insertionTime = MovieTime.make_movietime(timevalue: 0, timescale: 6000)
    insertTrackSegmentCommand = CommandModule.make_inserttracksegment(
                                movieEditorObject, 
                         track: targetTID,
                 source_object: movieImporter,
                  source_track: sourceTrack,
                 insertiontime: insertionTime, 
              source_timerange: sourceTimeRange)

    theCommands.add_command(insertTrackSegmentCommand)
    
    # 2.5 Create the get segment mappings command.
    getSegmentMappingsCommand = CommandModule.make_get_objectproperty(
                                movieEditorObject,
                      property: :tracksegmentmappings)
    getSegmentMappingsCommand.add_option(key: :track, value: targetTID)
    theCommands.add_command(getSegmentMappingsCommand)
    result = Smig.perform_commands(theCommands)
    expectedResult = '[{"sourcetimerange":{"start":{"flags":1,"value":0,'\
    '"timescale":6000,"epoch":0},"duration":{"flags":1,"value":12000,"timescale"'\
    ':6000,"epoch":0}},"targettimerange":{"start":{"flags":1,"value":0,'\
    '"timescale":6000,"epoch":0},"duration":{"flags":1,"value":12000,'\
    '"timescale":6000,"epoch":0}}}]'
    
    unless expectedResult.eql?(result)
      fail "1. Segment mapping different from expected #{result}"
    end

    # 2.6 Add an empty segment. This should push original segment later by 2 secs
    theCommands = SmigCommands.new
    emptySegmentTimeRange = MovieTime.make_movie_timerange(start: timeZero,
                                                        duration: duration)
    insertEmptySegmentCommand = CommandModule.make_insertemptysegment(
                                    movieEditorObject,
                             track: targetTID,
                insertiontimerange: emptySegmentTimeRange)
    theCommands.add_command(insertEmptySegmentCommand)
    theCommands.add_command(getSegmentMappingsCommand)
    result = Smig.perform_commands(theCommands)
    expectedResult = '[{"sourcetimerange":{"start":{"flags":1,"value":0,'\
    '"timescale":6000,"epoch":0},"duration":{"flags":1,"value":12000,'\
    '"timescale":6000,"epoch":0}},"targettimerange":{"start":{"flags":1,'\
    '"value":12000,"timescale":6000,"epoch":0},"duration":{"flags":1,"value":'\
    '12000,"timescale":6000,"epoch":0}}}]'
    
    unless expectedResult.eql?(result)
      fail "2. Segment mapping different from expected #{result}"
    end

    # 2.7 Add a second movie segment.
    theCommands = SmigCommands.new
    timeTwoSecsIn = MovieTime.make_movietime(timevalue: 12000, timescale: 6000)
    duration = MovieTime.make_movietime(timevalue: 12000, timescale: 6000)
    sourceTimeRange = MovieTime.make_movie_timerange(start: timeTwoSecsIn,
                                                  duration: duration)
    insertionTime = timeZero
    insertTrackSegmentCommand = CommandModule.make_inserttracksegment(
                                movieEditorObject, 
                         track: targetTID,
                 source_object: movieImporter,
                  source_track: sourceTrack,
                 insertiontime: insertionTime, 
              source_timerange: sourceTimeRange)

    theCommands.add_command(insertTrackSegmentCommand)
    # 2.8 Add a get segments mapping command.
    theCommands.add_command(getSegmentMappingsCommand)
    result = Smig.perform_commands(theCommands)
    expectedResult = '[{"sourcetimerange":{"start":{"flags":1,"value":12000,'\
    '"timescale":6000,"epoch":0},"duration":{"flags":1,"value":12000,'\
    '"timescale":6000,"epoch":0}},"targettimerange":{"start":{"flags":1,'\
    '"value":0,"timescale":6000,"epoch":0},"duration":{"flags":1,"value":12000,'\
    '"timescale":6000,"epoch":0}}},{"sourcetimerange":{"start":{"flags":1,'\
    '"value":0,"timescale":6000,"epoch":0},"duration":{"flags":1,"value":12000'\
    ',"timescale":6000,"epoch":0}},"targettimerange":{"start":{"flags":1,'\
    '"value":24000,"timescale":6000,"epoch":0},"duration":{"flags":1,"value"'\
    ':12000,"timescale":6000,"epoch":0}}}]'
    unless expectedResult.eql?(result)
      fail "3. Segment mapping different from expected #{result}"
    end

    # 2.9 Add a single passthru layer instruction to cover length of video track.
    theCommands = SmigCommands.new
    sixSeconds = MovieTime.make_movietime(timevalue: 36000, timescale: 6000)

    instructionTimeRange = MovieTime.make_movie_timerange(start: timeZero,
                                                       duration: sixSeconds)
    layerInstructions = VideoLayerInstructions.new
    layerInstructions.add_passthrulayerinstruction(track: targetTID)
    videoInstruction = CommandModule.make_addvideoinstruction(movieEditorObject,
                            timerange: instructionTimeRange,
                    layerinstructions: layerInstructions)
    theCommands.add_command(videoInstruction)
    # 2.10 Copy the composition map image to the image collection.
    imageIdentifier = SecureRandom.uuid
    addCompositionToImageCollection = CommandModule.make_assignimage_tocollection(
                                                movieEditorObject,
                                    identifier: imageIdentifier)
    theCommands.add_command(addCompositionToImageCollection)
    cleanupCommands.add_tocleanupcommands_removeimagefromcollection(imageIdentifier)
    # 2.11 Save the composition map image
    # First create an image exporter object and add it to the cleanup commands.
    compMapFileName = "compositionmap.jpg"
    exportPath = File.join(Dir.tmpdir(), compMapFileName)
    # exportPath = File.join($compareImageDir, compMapFileName)
    exporterObject = theCommands.make_createexporter(exportPath,
                                        export_type: "public.jpeg",
                                       addtocleanup: false)
    cleanupCommands.add_tocleanupcommands_closeobject(exporterObject)
    addImageToExporterCommand = CommandModule.make_addimage_fromimagecollection(
      exporterObject, imageidentifier: imageIdentifier)
    theCommands.add_command(addImageToExporterCommand)
    exportCommand = CommandModule.make_export(exporterObject)
    theCommands.add_command(exportCommand)
    Smig.perform_commands(theCommands)
    # `open #{exportPath}`
    origFile = File.join($compareImageDir, compMapFileName)
    compareResult = AreImageFilesSame(origFile, exportPath, 0)
    unless compareResult
      # 2.12 Report if different.
      fail "2.12 Different image files: " + origFile + " and " + tempFile
    end

    # 2.13 Export the movie composition.
    theCommands.clear
    movieFileName = "videowithemptysegment.mov"
    movieExportPath = File.join(Dir.tmpdir(), movieFileName)
    fileType = "com.apple.quicktime-movie"
    exportMovieCommand = CommandModule.make_movieeditor_export(movieEditorObject,
                                exportpreset: :AVAssetExportPreset1280x720,
                              exportfilepath: movieExportPath,
                              exportfiletype: fileType)
    theCommands.add_command(exportMovieCommand)
    Smig.perform_commands(theCommands)
    theCommands.clear
    
    # 2.14 Now import the movie so that we can check the video track properties.
    movieImporter2 = theCommands.make_createmovieimporter(movieExportPath,
                                           addtocleanup: false)
    cleanupCommands.add_tocleanupcommands_closeobject(movieImporter2)
    getMovieTrackPropertiesCommand = CommandModule.make_get_objectproperties(
                                                          movieImporter2)
    theTrack = MovieTrackIdentifier.make_movietrackid_from_mediatype(
      mediatype: :vide, trackindex: 0)

    getMovieTrackPropertiesCommand.add_option(key: :track, value: theTrack)
    theCommands.add_command(getMovieTrackPropertiesCommand)
    theResult = Smig.perform_commands(theCommands)
    origResult = JSON.parse('{"naturalsize":{"width":1280,"height":720},'\
    '"minframeduration":{"flags":1,"value":3002,"timescale":90000,"epoch":0},'\
    '"mediatype":"vide","timerange":{"start":{"flags":1,"value":0,"timescale":'\
    '90000,"epoch":0},"duration":{"flags":1,"value":540360,"timescale":90000'\
    ',"epoch":0}},"trackid":1,"languagecode":"und","languagetag":"",'\
    '"affinetransform":{"m12":0,"m21":0,"m22":1,"tY":0,"m11":1,"tX":'\
    '0},"requiresframereordering":true,"trackenabled":true,"framerate":29.98001}')
    newResult = JSON.parse(theResult)
    # puts "#{origResult}"
    # puts "#{newResult}"
    unless origResult["naturalsize"]["width"].eql?(newResult["naturalsize"]["width"]) &&
          origResult["timerange"]["duration"]["value"].eql?(newResult["timerange"]["duration"]["value"])
      fail "2.14 Different track properties: #{theResult}"
    end
    # puts theResult
    
  rescue RuntimeError => e
    $errorcode = Smig.exitvalue
    unless $errorcode.zero?
      puts "Exit string: " + Smig.exitstring
      puts " Exit status: " + $errorcode.to_s
    end
    puts e.message
    puts e.backtrace.to_s
  ensure
    Smig.perform_commands(cleanupCommands)
    FileUtils.rm_f(exportPath) unless exportPath.nil?
    FileUtils.rm_f(movieExportPath) unless movieExportPath.nil?
    # `open #{movieExportPath}` unless movieExportPath.nil?
  end
end

# 3 Create a movie editor object with multiple video tracks, with transitions.
# 3.0 Create a movie editor object
# 3.1 Add three video tracks.
# 3.2 Confirm that the number of tracks is 3.
# 3.3 Import a movie file.
# 3.4 Add content to all three tracks that overlaps.
# 3.5 Add instructions.
# 3.6 Copy the composition map image to the image collection.
# 3.7 Save the composition map image
# 3.8 Compare the composition map image with a previously generated one.
# 3.9 Export the video compostion.
# 3.10 Import the exported movie and check movie length and size.

def test03()
  movieEditorObject = nil
  begin
    theCommands = SmigCommands.new
    
    # Create a Smig commands object purely used to cleanup on script completion.
    cleanupCommands = SmigCommands.new
    # 3.0 Create a movie editor object.
    movieEditorObject = theCommands.make_createmovieeditor(addtocleanup: false)

    cleanupCommands.add_tocleanupcommands_closeobject(movieEditorObject)
    
    # 3.1 Add two video tracks.
    # Leave track id unspecified and one will be assigned.
    addVideoTrackCommand = CommandModule.make_createtrackcommand(
                                                movieEditorObject,
                                     mediatype: :vide)
    theCommands.add_command(addVideoTrackCommand)
    # Since we are not specifying the persistent track id, the create track
    # command is the same for creating all 3 tracks.
    theCommands.add_command(addVideoTrackCommand)
    theCommands.add_command(addVideoTrackCommand)

    # 3.2 Confirm that there is three tracks.
    getNumTracks = CommandModule.make_get_objectproperty(movieEditorObject,
                                                      property: :numberoftracks)
    theCommands.add_command(getNumTracks)
    
    numTracks = Smig.perform_commands(theCommands)
    fail "Should have 3 video tracks is #{numTracks}" unless numTracks.eql?("3")

    theCommands.clear
    # 3.3 Import a movie file.
    sourceMovie = File.join($directory, "images/testinput-movingimages.mov")
    movieImporter = theCommands.make_createmovieimporter(sourceMovie,
                                                         addtocleanup: false)
    cleanupCommands.add_tocleanupcommands_closeobject(movieImporter)
    # Specify that the content will be from the first video track in movie file.
    sourceTrack = MovieTrackIdentifier.make_movietrackid_from_mediatype(
      mediatype: :vide, trackindex: 0)
    
=begin
create 3 tracks.

The first track is scaled down to display in the bottom right corner for the full
length of the movie. Scale is 0.333, 0.333. There are two ways to do this,
specify the preferred transform for the track, and use a passthru layer
instruction for the track in all instructions or, add a transform layer
instruction for the track in every instruction. Generated movie should be 10
seconds long.

I'm going to go with the first option for now, specifying the preferred transform
for the first track. This might cause problems if the movie decides to make the
size of video tracks to be the transformed size of the first video track.

First option didn't work, preferred transform is for display not composition.
So use a transform layer instruction and apply it to first track.

Tracks two and three have an opacity ramp then crop ramp between the two.
IN = Instruction

————————————————————  T0
————————    ————————  T1
    ————————————      T2
     OR      CR
 
IN1 IN2 IN3 IN4  IN5

OR is an opacity ramp that ramps the opacity from T1 to T2, CR is a crop
ramp that crops T2 from no cropping to a small centred crop rect.

IN1 [ T0PTLI, T1PTLI ] for 2 seconds.
IN2 [ T0PTLI, T1ORLI, T2PTLI ] for 2 seconds.
IN3 [ T0PTLI, T2PTLI ] for 2 seconds.
IN4 [ T0PTLI, T2CRLI, T1PTLI ] for 2 seconds.
IN5 [ T0PTLI, T1PTLI ] for 2 seconds.

T0 Track 0
T1 Track 1
T2 Track 2
PT PassThru
OR Opacity Ramp
CR Crop Ramp
LI Layer Instruction
[] indicates an array of layer instructions.
=end
    # 3.4 Add content to all three tracks that overlaps.
    # First add 10 seconds of content to T0
    track0 = MovieTrackIdentifier.make_movietrackid_from_mediatype(
                                            mediatype: :vide, trackindex: 0)
    sourceTrack = MovieTrackIdentifier.make_movietrackid_from_mediatype(
                                            mediatype: :vide, trackindex: 0)

    timeZero = MovieTime.make_movietime(timevalue: 0, timescale: 6000)
    duration = MovieTime.make_movietime(timevalue: 60000, timescale: 6000)
    sourceTimeRange = MovieTime.make_movie_timerange(start: timeZero,
                                                  duration: duration)
    insertionTime = MovieTime.make_movietime(timevalue: 0, timescale: 6000)
    insertTrackSegmentCommand = CommandModule.make_inserttracksegment(
                                movieEditorObject, 
                         track: track0,
                 source_object: movieImporter,
                  source_track: sourceTrack,
                 insertiontime: timeZero, 
              source_timerange: sourceTimeRange)

    theCommands.add_command(insertTrackSegmentCommand)
    # Now set the preferred transform of track 0. Original movie 1280x720

    # Now add content to T1. Two segments of content to be added.
    # Each 4 seconds long.
    # First segment is last 4 seconds of source track. Then a two second break.
    # Second segment is first 4 seconds of source track.
    fourSeconds = MovieTime.make_movietime(timevalue: 24000, timescale: 6000)
    sixSeconds = MovieTime.make_movietime(timevalue: 36000, timescale: 6000)
    track1 = MovieTrackIdentifier.make_movietrackid_from_mediatype(
                                            mediatype: :vide, trackindex: 1)
    sourceTimeRange2 = MovieTime.make_movie_timerange(start: sixSeconds,
                                                   duration: fourSeconds)
    insertTrackSegmentCommand2 = CommandModule.make_inserttracksegment(
                                movieEditorObject, 
                         track: track1,
                 source_object: movieImporter,
                  source_track: sourceTrack,
                 insertiontime: timeZero, 
              source_timerange: sourceTimeRange2)
    theCommands.add_command(insertTrackSegmentCommand2)
    sourceTimeRange3 = MovieTime.make_movie_timerange(start: timeZero,
                                                   duration: fourSeconds)
    insertTrackSegmentCommand3 = CommandModule.make_inserttracksegment(
                                movieEditorObject, 
                         track: track1,
                 source_object: movieImporter,
                  source_track: sourceTrack,
                 insertiontime: sixSeconds, 
              source_timerange: sourceTimeRange3)
    theCommands.add_command(insertTrackSegmentCommand3)
    
    # Now add content to T2. One segment to be added. 4 seconds long, starting
    # at 2 seconds in with source content starting at 3 seconds in.
    twoSeconds = MovieTime.make_movietime(timevalue: 12000, timescale: 6000)
    threeSeconds = MovieTime.make_movietime(timevalue: 18000, timescale: 6000)
    track2 = MovieTrackIdentifier.make_movietrackid_from_mediatype(
                                            mediatype: :vide, trackindex: 2)
    sourceTimeRange4 = MovieTime.make_movie_timerange(start: twoSeconds,
                                                   duration: sixSeconds)
    insertTrackSegmentCommand4 = CommandModule.make_inserttracksegment(
                                movieEditorObject, 
                         track: track2,
                 source_object: movieImporter,
                  source_track: sourceTrack,
                 insertiontime: twoSeconds, 
              source_timerange: sourceTimeRange4)
    theCommands.add_command(insertTrackSegmentCommand4)
    
    # 3.5 Now add composition instructions.
    # IN1 [ T0PTLI, T1PTLI ] for 2 seconds.
    # First layer instruction is a transform instruction for track 0.
    # Then a pass thru layer instruction for track 1.

    contextTransformation = MITransformations.make_contexttransformation
    translatePoint = MIShapes.make_point(853.3, 480)
    MITransformations.add_translatetransform(contextTransformation, translatePoint)
    scaleXY = MIShapes.make_point(0.3333333, 0.3333333)
    MITransformations.add_scaletransform(contextTransformation, scaleXY)

    li1 = VideoLayerInstructions.new
    # li1.add_passthrulayerinstruction(track: track0)
    li1.add_transformlayerinstruction(track: track0,
                             transformvalue: contextTransformation)
    li1.add_passthrulayerinstruction(track: track1)
    videoI1TimeRange = MovieTime.make_movie_timerange(start: timeZero,
                                                   duration: twoSeconds)
    videoI1Command = CommandModule.make_addvideoinstruction(movieEditorObject,
                                                 timerange: videoI1TimeRange,
                                         layerinstructions: li1)
    theCommands.add_command(videoI1Command)

    # IN2 [ T0PTLI, T1ORLI, T2PTLI ] for 2 seconds.
    li2 = VideoLayerInstructions.new
    videoI2TimeRange = MovieTime.make_movie_timerange(start: twoSeconds,
                                                   duration: twoSeconds)
    li2.add_transformlayerinstruction(track: track0,
                             transformvalue: contextTransformation)
#    li2.add_passthrulayerinstruction(track: track0)
    li2.add_opacityramplayerinstruction(track: track1,
                            startopacityvalue: 1.0,
                              endopacityvalue: 0.0,
                                    timerange: videoI2TimeRange)

    li2.add_passthrulayerinstruction(track: track2)
    videoI2Command = CommandModule.make_addvideoinstruction(movieEditorObject,
                                                 timerange: videoI2TimeRange,
                                         layerinstructions: li2)
    theCommands.add_command(videoI2Command)

    # IN3 [ T0PTLI, T2PTLI ] for 2 seconds.
    li3 = VideoLayerInstructions.new
    li3.add_transformlayerinstruction(track: track0,
                             transformvalue: contextTransformation)
    li3.add_passthrulayerinstruction(track: track2)
    videoI3TimeRange = MovieTime.make_movie_timerange(start: fourSeconds,
                                                   duration: twoSeconds)
    videoI3Command = CommandModule.make_addvideoinstruction(movieEditorObject,
                                                 timerange: videoI3TimeRange,
                                         layerinstructions: li3)
    theCommands.add_command(videoI3Command)

    # IN4 [ T0PTLI, T2CRLI, T1PTLI ] for 2 seconds.
    li4 = VideoLayerInstructions.new
    videoI4TimeRange = MovieTime.make_movie_timerange(start: sixSeconds,
                                                   duration: twoSeconds)
    li4.add_transformlayerinstruction(track: track0,
                             transformvalue: contextTransformation)
    startCropRect = MIShapes.make_rectangle(size: { width: 1280, height: 720 })
    endCropRect = MIShapes.make_rectangle(width: 16, height: 16,
                                           xloc: 623,  yloc: 352)
    li4.add_croprectramplayerinstruction(track: track2,
                            startcroprectvalue: startCropRect,
                              endcroprectvalue: endCropRect,
                                     timerange: videoI4TimeRange)

    li4.add_passthrulayerinstruction(track: track1)
    videoI4Command = CommandModule.make_addvideoinstruction(movieEditorObject,
                                                 timerange: videoI4TimeRange,
                                         layerinstructions: li4)
    theCommands.add_command(videoI4Command)

    # IN5 [ T0PTLI, T1PTLI ] for 2 seconds.
    li5 = VideoLayerInstructions.new
    li5.add_transformlayerinstruction(track: track0,
                             transformvalue: contextTransformation)
    li5.add_passthrulayerinstruction(track: track1)
    eightSeconds = MovieTime.make_movietime(timevalue: 48000, timescale: 6000)
    videoI5TimeRange = MovieTime.make_movie_timerange(start: eightSeconds,
                                                   duration: twoSeconds)
    videoI5Command = CommandModule.make_addvideoinstruction(movieEditorObject,
                                                 timerange: videoI5TimeRange,
                                         layerinstructions: li5)
    theCommands.add_command(videoI5Command)

    # 3.6 Copy the composition map image to the image collection.
    imageIdentifier = SecureRandom.uuid
    addCompositionToImageCollection = CommandModule.make_assignimage_tocollection(
                                                movieEditorObject,
                                    identifier: imageIdentifier)
    theCommands.add_command(addCompositionToImageCollection)
    cleanupCommands.add_tocleanupcommands_removeimagefromcollection(
                                                imageIdentifier)

    # 3.7 Save the composition map image
    # First create an image exporter object and add it to the cleanup commands.
    compMapFileName = "compositionmap03.jpg"
    # exportPath = File.join($compareImageDir, compMapFileName)
    exportPath = File.join(Dir.tmpdir(), compMapFileName)
    exporterObject = theCommands.make_createexporter(exportPath,
                                        export_type: "public.jpeg",
                                       addtocleanup: false)
    cleanupCommands.add_tocleanupcommands_closeobject(exporterObject)
    addImageToExporterCommand = CommandModule.make_addimage_fromimagecollection(
                                    exporterObject,
                   imageidentifier: imageIdentifier)
    theCommands.add_command(addImageToExporterCommand)
    exportCommand = CommandModule.make_export(exporterObject)
    theCommands.add_command(exportCommand)
    Smig.perform_commands(theCommands)

    # 3.8 Compare the composition map image with a previously generated one.
    # `open #{exportPath}`
    origFile = File.join($compareImageDir, compMapFileName)
    compareResult = AreImageFilesSame(origFile, exportPath, 0)
    unless compareResult
      fail "3.8 Different image files: " + origFile + " and " + tempFile
    end

    # 3.9 Export the video compostion.
    theCommands.clear
    movieFileName = "videowithinstructions.mp4"
    movieExportPath = File.join(Dir.tmpdir(), movieFileName)
    # movieExportPath = File.join(File.expand_path("~/Desktop"), movieFileName)
    fileType = "public.mpeg-4"
    exportMovieCommand = CommandModule.make_movieeditor_export(
                                              movieEditorObject,
                                exportpreset: :AVAssetExportPreset1280x720,
                              exportfilepath: movieExportPath,
                              exportfiletype: fileType)
    theCommands.add_command(exportMovieCommand)
    Smig.perform_commands(theCommands)
    
    theCommands.clear
    
    # 3.10 Import the exported movie and check movie length and size.
    movieImporter2 = theCommands.make_createmovieimporter(movieExportPath,
                                           addtocleanup: false)
    cleanupCommands.add_tocleanupcommands_closeobject(movieImporter2)
    getMovieTrackPropertiesCommand = CommandModule.make_get_objectproperties(
                                                          movieImporter2)
    theTrack = MovieTrackIdentifier.make_movietrackid_from_mediatype(
      mediatype: :vide, trackindex: 0)

    getMovieTrackPropertiesCommand.add_option(key: :track, value: theTrack)
    theCommands.add_command(getMovieTrackPropertiesCommand)
    theResult = Smig.perform_commands(theCommands)
    origResult = JSON.parse('{"naturalsize":{"width":1280,"height":720},'\
    '"minframeduration":{"flags":1,"value":3002,"timescale":90000,"epoch":0},'\
    '"mediatype":"vide","timerange":{"start":{"flags":1,"value":0,"timescale":'\
    '90000,"epoch":0},"duration":{"flags":1,"value":900600,"timescale":90000,'\
    '"epoch":0}},"trackid":1,"languagecode":"und","languagetag":"",'\
    '"affinetransform":{"m12":0,"m21":0,"m22":1,"tY":0,"m11":1,"tX":'\
    '0},"requiresframereordering":true,"trackenabled":true,"framerate":29.98001}')
    newResult = JSON.parse(theResult)
    unless origResult["naturalsize"]["width"].eql?(newResult["naturalsize"]["width"]) &&
          origResult["timerange"]["duration"]["value"].eql?(newResult["timerange"]["duration"]["value"])
      fail "3.10 Different track properties: #{theResult}"
    end
  rescue RuntimeError => e
    $errorcode = Smig.exitvalue
    unless $errorcode.zero?
      puts "Exit string: " + Smig.exitstring
      puts " Exit status: " + $errorcode.to_s
    end
    puts e.message
    puts e.backtrace.to_s
  ensure
    Smig.perform_commands(cleanupCommands)
    FileUtils.rm_f(exportPath) unless exportPath.nil?
    FileUtils.rm_f(movieExportPath) unless movieExportPath.nil?
    # `open #{movieExportPath}` unless movieExportPath.nil?
  end
end

# Tests the application of audio instructions set volume, and volume ramp.
# 1. Import a movie file
# 2. Create a movie editor object.
# 3. Add a video track to the movie editor.
# 4. Add a 4 second segment to the video track from the imported movie.
# 5. Add a passthru layer instruction to the video track.
# 6. Add two audio tracks to the movie editor.
# 7. Add content (track segments to each of the two audio tracks.)
# 8. Set the volume for audio track 2 to 0 from the start.
# 9. Set the volume ramp for audio track 1 to go from 1 to 0. Time range 1..3
# 10. Set the volume ramp for audio track 2 to go from 0 to 1. Time range 1..3
# 11. Export the movie composition.
# 12. Assign the composition map image to the image collection
# 13. Add removing the composition map image command to cleanup commands.
# 14. Create an exporter.
# 15. Add image from image collection to exporter.
# 16. Export image
# 17. Compare images.
# 18. Compare movie file audio track metadata.
def test04
  begin
    movieImportPath = File.join($directory, "images", "418_clip5_sd.m4v")
    theCommands = SmigCommands.new
    # 1. Import the source movie.
    movieImporter = theCommands.make_createmovieimporter(movieImportPath)
    
    # 2. Create the movie editor object.
    movieEditor = theCommands.make_createmovieeditor()

    # 3. Add a video track to the movie editor.
    videoTrack = MovieTrackIdentifier.make_movietrackid_from_mediatype(
      mediatype: :vide, trackindex: 0)

    addVideoTrackCommand = CommandModule.make_createtrackcommand(movieEditor)
    theCommands.add_command(addVideoTrackCommand)

    # 4. Add a 4 second segment to the video track from the imported movie.
    insertionTime = MovieTime.make_movietime(timescale: 600, timevalue: 0)
    duration  = MovieTime.make_movietime_fromseconds(4)
    startTime = MovieTime.make_movietime_fromseconds(0)
    sourceTimeRange = MovieTime.make_movie_timerange(start: startTime,
                                                  duration: duration)
    insertVideoContent = CommandModule.make_inserttracksegment(movieEditor,
                            track: videoTrack,
                    source_object: movieImporter,
                     source_track: videoTrack,
                    insertiontime: insertionTime,
                 source_timerange: sourceTimeRange)
    theCommands.add_command(insertVideoContent)
    
    # 5. Add a passthru layer instruction to the video track.
    layerInstructions = VideoLayerInstructions.new
    layerInstructions.add_passthrulayerinstruction(track: videoTrack)
    passthruTimeRange = MovieTime.make_movie_timerange(start: insertionTime,
                                                    duration: duration)
    videoPassthruCommand = CommandModule.make_addvideoinstruction(movieEditor,
                                                 timerange: passthruTimeRange,
                                         layerinstructions: layerInstructions)
    theCommands.add_command(videoPassthruCommand)
    
    # 6. Add two audio tracks to the movie editor.
    audioTrack1 = MovieTrackIdentifier.make_movietrackid_from_mediatype(
      mediatype: :soun, trackindex: 0)
    audioTrack2 = MovieTrackIdentifier.make_movietrackid_from_mediatype(
      mediatype: :soun, trackindex: 1)

    addAudioTrackCommand = CommandModule.make_createtrackcommand(movieEditor,
      mediatype: :soun)
    theCommands.add_command(addAudioTrackCommand)
    theCommands.add_command(addAudioTrackCommand)
    
    # 7. Add audio content (track segments to each of the two audio tracks.)
    startTime0 = MovieTime.make_movietime_fromseconds(0)
    startTime4 = MovieTime.make_movietime_fromseconds(4)
    sourceTimeRange4 = MovieTime.make_movie_timerange(start: startTime4,
                                                   duration: duration)
    insertAudioContent = CommandModule.make_inserttracksegment(movieEditor,
                            track: audioTrack1,
                    source_object: movieImporter,
                     source_track: audioTrack1,
                    insertiontime: insertionTime,
                 source_timerange: sourceTimeRange4)
    theCommands.add_command(insertAudioContent)
    
    insertAudioContent2 = CommandModule.make_inserttracksegment(movieEditor,
                            track: audioTrack2,
                    source_object: movieImporter,
                     source_track: audioTrack1,
                    insertiontime: insertionTime,
                 source_timerange: sourceTimeRange)
    theCommands.add_command(insertAudioContent2)
    
    # 8. Set the volume for audio track 2 to 0 from the start.
    volumeInstruction = AudioInstruction.new(track: audioTrack2)
    
    volumeInstruction.set_volume_instruction(time: startTime0, volume: 0.0)
    addAudioInstruction = CommandModule.make_addaudioinstruction(movieEditor,
                                               audioinstruction: volumeInstruction)
    theCommands.add_command(addAudioInstruction)

    # 9. Set the volume ramp for audio track 1 to go from 1 to 0. Time range 1..3
    rampDuration = MovieTime.make_movietime_fromseconds(2)
    rampStart = MovieTime.make_movietime_fromseconds(1)
    rampTimeRange = MovieTime.make_movie_timerange(start: rampStart,
                                                duration: rampDuration)
    volumeRampInstruction1 = AudioInstruction.new(track: audioTrack1)
    volumeRampInstruction1.set_volumeramp_instruction(timerange: rampTimeRange,
                                                    startvolume: 1.0,
                                                      endvolume: 0.0)
    addAudioVolumeRamp1 = CommandModule.make_addaudioinstruction(movieEditor,
                                               audioinstruction: volumeRampInstruction1)
    theCommands.add_command(addAudioVolumeRamp1)

    # 10. Set the volume ramp for audio track 2 to go from 0 to 1. Time range 1..3
    volumeRampInstruction2 = AudioInstruction.new(track: audioTrack2)
    volumeRampInstruction2.set_volumeramp_instruction(timerange: rampTimeRange,
                                                    startvolume: 0.0,
                                                      endvolume: 1.0)
    addAudioVolumeRamp2 = CommandModule.make_addaudioinstruction(movieEditor,
                                               audioinstruction: volumeRampInstruction2)
    theCommands.add_command(addAudioVolumeRamp2)

    # 11. Export the movie composition.
    movieFileName = "audiowithvolumeramp.mov"
    movieExportPath = File.join("~/Movies", movieFileName)
    fileType = "com.apple.quicktime-movie"
    exportMovieCommand = CommandModule.make_movieeditor_export(movieEditor,
                                exportpreset: :AVAssetExportPreset960x540,
                              exportfilepath: movieExportPath,
                              exportfiletype: fileType)
    theCommands.add_command(exportMovieCommand)
    
    # 12. Assign the composition map image to the image collection
    imageIdentifier = SecureRandom.uuid
    addCompositionToImageCollection = CommandModule.make_assignimage_tocollection(
                                                movieEditor,
                                    identifier: imageIdentifier)
    theCommands.add_command(addCompositionToImageCollection)
    
    # 13. Add removing the composition map image command to cleanup commands.
    theCommands.add_tocleanupcommands_removeimagefromcollection(imageIdentifier)
    
    # 14. Create an exporter.
    compMapFileName = "compositionmap04.jpg"
    # exportPath = File.join($compareImageDir, compMapFileName)
    exportPath = File.join(Dir.tmpdir(), compMapFileName)
    exporterObject = theCommands.make_createexporter(exportPath,
                                        export_type: "public.jpeg")
  
    # 15. Add image from image collection to exporter.
    addImageToExporterCommand = CommandModule.make_addimage_fromimagecollection(
                                    exporterObject,
                   imageidentifier: imageIdentifier)
    theCommands.add_command(addImageToExporterCommand)
    
    # 16. Export image
    exportCommand = CommandModule.make_export(exporterObject)
    theCommands.add_command(exportCommand)

    Smig.perform_commands(theCommands)

    # 17. Compare images.
    origCompMap = File.join($compareImageDir, compMapFileName)
    unless AreImageFilesSame(origCompMap, exportPath)
      raise "Different image files: " + origFile + " and " + tempFile
    end

    # 18. Compare audio track metadata.
    theCommands.clear
    movieImporter2 = theCommands.make_createmovieimporter(movieExportPath)
    getMovieTrackPropertiesCommand = CommandModule.make_get_objectproperties(
                                                          movieImporter2)
    theTrack = MovieTrackIdentifier.make_movietrackid_from_mediatype(
      mediatype: :soun, trackindex: 0)

    getMovieTrackPropertiesCommand.add_option(key: :track, value: theTrack)
    theCommands.add_command(getMovieTrackPropertiesCommand)
    theResult = Smig.perform_commands(theCommands)
    origResult = '{"preferredvolume":1,"mediatype":"soun","timerange":{"start":{"flags":1,"value":0,"timescale":90000,"epoch":0},"duration":{"flags":1,"value":359952,"timescale":90000,"epoch":0}},"trackid":1,"languagecode":"und","languagetag":"","trackenabled":true}'
    unless theResult.eql? origResult
      raise "Audio track metadata has changed"
    end

  rescue RuntimeError => e
    $errorcode = Smig.exitvalue
    unless $errorcode.zero?
      puts "Exit string: " + Smig.exitstring
      puts " Exit status: " + $errorcode.to_s
    end
    puts e.message
    puts e.backtrace.to_s
  ensure
    FileUtils.rm_f(exportPath) unless exportPath.nil?
    # FileUtils.rm_f(movieExportPath) unless movieExportPath.nil?
    # `open #{movieExportPath}` unless movieExportPath.nil?
  end
end

def LocalTestMain018()
  begin
    puts "test01"
    test01()
    puts "test02"
    test02()
    puts "test03"
    test03()
    puts "test04"
    test04()
  rescue RuntimeError => e
    puts e.message
    # puts e.backtrace
    puts "Error code: #{$errorcode}"
    puts "Smig.exitstring: #{Smig.exitstring}"
    # don't allow the exception to propagate outside of this file.
  end
  return $errorcode
end

exit(LocalTestMain018())

